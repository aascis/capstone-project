import fetch from 'node-fetch';

// Zammad ticket interface for API operations
interface ZammadTicket {
  id?: number;
  title?: string;
  state_id?: number;
  priority_id?: number;
  customer_id?: number;
  group_id?: number;
  article?: {
    subject?: string;
    body?: string;
    type?: string;
    internal?: boolean;
  };
  created_at?: string;
  updated_at?: string;
}

// Simplified ticket interface for our application
interface Ticket {
  ticketId?: string;
  subject?: string;
  description?: string;
  status?: 'open' | 'in_progress' | 'pending' | 'resolved' | 'closed';
  priority?: 'low' | 'medium' | 'high' | 'critical';
}

// Check if environment variables are set
const ZAMMAD_URL = process.env.ZAMMAD_URL || "http://zammad.star.ca:8080";
const ZAMMAD_TOKEN = process.env.ZAMMAD_TOKEN;

class ZammadService {
  private baseUrl: string;
  private token: string;

  constructor() {
    if (!ZAMMAD_URL) {
      console.warn('ZAMMAD_URL environment variable is not set. Using default: http://zammad.star.ca:8080');
    }
    
    if (!ZAMMAD_TOKEN) {
      console.warn('ZAMMAD_TOKEN environment variable is not set. Zammad integration will use basic auth fallback.');
    }
    
    this.baseUrl = ZAMMAD_URL;
    this.token = ZAMMAD_TOKEN || '';
  }

  private async request(endpoint: string, method: string = 'GET', data?: any): Promise<any> {
    console.log('=== DEBUG: Zammad request called ===');
    console.log('Endpoint:', endpoint);
    console.log('Method:', method);
    console.log('Data:', JSON.stringify(data, null, 2));

    const url = `${this.baseUrl}${endpoint}`;
    const headers: any = {
      'Content-Type': 'application/json'
    };

    // Use token auth if available, otherwise basic auth will be handled at request level
    if (this.token) {
      headers['Authorization'] = `Token token=${this.token}`;
    }
    
    const options: any = {
      method,
      headers
    };
    
    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      options.body = JSON.stringify(data);
    }
    
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Zammad API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
      
      // For DELETE requests or other responses without content
      if (response.status === 204 || response.headers.get('content-length') === '0') {
        return {};
      }
      
      return await response.json();
    } catch (error: any) {
      console.error(`Zammad API request failed: ${error.message}`);
      throw error;
    }
  }

  // Make request with specific customer ID for on-behalf-of
  private async requestWithCustomer(endpoint: string, method: string, data: any, customerId: number): Promise<any> {
    console.log('=== DEBUG: Making request with customer ID ===', customerId);
    
    const url = `${this.baseUrl}${endpoint}`;
    const headers: any = {
      'Content-Type': 'application/json'
    };

    if (this.token) {
      headers['Authorization'] = `Token token=${this.token}`;
      headers['X-On-Behalf-Of'] = customerId.toString();
    }
    
    const options: any = {
      method,
      headers,
      body: JSON.stringify(data)
    };
    
    console.log('Request headers:', JSON.stringify(headers, null, 2));
    console.log('Request body:', JSON.stringify(data, null, 2));
    
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Zammad API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
      
      return await response.json();
    } catch (error: any) {
      console.error(`Zammad API request failed: ${error.message}`);
      throw error;
    }
  }
  
  // Get all tickets associated with a customer email
async getTicketsByCustomer(email: string): Promise<any[]> {
  try {
    console.log('=== DEBUG: getTicketsByCustomer called for:', email);
    
    // First, find the customer by email
    const searchResult = await this.request(`/api/v1/users/search?query=${encodeURIComponent(email)}`);
    
    if (!searchResult || !searchResult.length) {
      console.log('No customer found for email:', email);
      return [];
    }
    
    const customer = searchResult[0];
    console.log('Found customer ID:', customer.id);
    
    // Strategy: Get tickets from all relevant groups, then filter by customer ID
    let allCustomerTickets: any[] = [];
    
    // Try searching across all groups that customers typically use
    const groupSearchQueries = [
      `customer_id:${customer.id} AND group_id:1`, // Users group
      `customer_id:${customer.id} AND group_id:2`, // Sales group  
      `customer_id:${customer.id} AND group_id:3`, // Support group
      `customer_id:${customer.id}`                 // Fallback without group filter
    ];
    
    for (const query of groupSearchQueries) {
      try {
        console.log(`Trying group search query: ${query}`);
        const tickets = await this.request(`/api/v1/tickets/search?query=${encodeURIComponent(query)}&limit=100`);
        console.log(`Group query "${query}" found:`, tickets ? tickets.length : 0);
        
        if (tickets && tickets.length > 0) {
          // Add tickets to our collection, avoiding duplicates
          const newTickets = tickets.filter((ticket: any) => 
            ticket.customer_id === customer.id && 
            !allCustomerTickets.some((existingTicket: any) => existingTicket.id === ticket.id)
          );
          allCustomerTickets = allCustomerTickets.concat(newTickets);
          console.log(`Added ${newTickets.length} new tickets from this query`);
        }
      } catch (queryError) {
        console.log(`Group query "${query}" failed:`, queryError.message);
        continue;
      }
    }
    
    // If group-specific searches didn't work, try alternative approaches
    if (allCustomerTickets.length === 0) {
      console.log('Group searches returned no results, trying alternative queries...');
      
      const alternativeQueries = [
        `customer.email:"${email}"`,
        `customer.email:${email}`,
        `customer_id:${customer.id}`,
        `customer.id:${customer.id}`
      ];
      
      for (const query of alternativeQueries) {
        try {
          console.log(`Trying alternative query: ${query}`);
          const tickets = await this.request(`/api/v1/tickets/search?query=${encodeURIComponent(query)}&limit=100`);
          console.log(`Alternative query "${query}" found:`, tickets ? tickets.length : 0);
          
          if (tickets && tickets.length > 0) {
            // Security: Only include tickets that belong to this customer
            const validTickets = tickets.filter((ticket: any) => ticket.customer_id === customer.id);
            console.log(`Valid tickets for customer ${customer.id}:`, validTickets.length);
            
            if (validTickets.length > 0) {
              allCustomerTickets = validTickets;
              break; // Found tickets, stop searching
            }
          }
        } catch (queryError) {
          console.log(`Alternative query "${query}" failed:`, queryError.message);
          continue;
        }
      }
    }
    
    console.log(`Final result: ${allCustomerTickets.length} tickets found for customer`);
    console.log('All customer tickets:', JSON.stringify(allCustomerTickets, null, 2));
    
    return allCustomerTickets;
    
  } catch (error) {
    console.error(`Error getting tickets for customer ${email}:`, error);
    throw error;
  }
}
  
  // Get a specific ticket by ID
  async getTicket(ticketId: string): Promise<any> {
    return await this.request(`/api/v1/tickets/${ticketId}`);
  }
  
  // Create a new ticket in Zammad
  async createTicket(ticketData: any): Promise<any> {
    console.log('=== DEBUG: createTicket called ===');
    console.log('Input data:', JSON.stringify(ticketData, null, 2));
    
    // Find the customer in Zammad to get their ID
    let customerId;
    try {
      const customer = await this.findCustomerByEmail(ticketData.customer.email);
      if (!customer) {
        console.log('Customer not found, creating new customer...');
        const newCustomer = await this.findOrCreateCustomer({
          email: ticketData.customer.email,
          name: ticketData.customer.name
        });
        customerId = newCustomer.id;
      } else {
        customerId = customer.id;
      }
      console.log('Using customer ID:', customerId);
    } catch (error) {
      console.error('Error finding customer:', error);
      throw new Error('Could not find or create customer in Zammad');
    }
    
    // Map department to group name
    const groupName = this.mapDepartmentToGroupName(ticketData.department || 'support');
    console.log('Mapped group name:', groupName);
    
    // Create the ticket with the correct Zammad API format
    const ticketPayload = {
      title: ticketData.subject || ticketData.title,
      group: groupName,
      customer: ticketData.customer.email,
      article: {
        subject: ticketData.subject || ticketData.title,
        body: ticketData.description || ticketData.body,
        type: 'note',
        internal: false
      }
    };
    
    console.log('Final payload:', JSON.stringify(ticketPayload, null, 2));
    
    // Use the dynamic customer ID for the On-Behalf-Of header
    return await this.requestWithCustomer('/api/v1/tickets', 'POST', ticketPayload, customerId);
  }
  
  // Map department to Zammad group names (not IDs)
  private mapDepartmentToGroupName(department: string): string {
    const departmentMap: { [key: string]: string } = {
      'sales': 'Sales',
      'support': 'Support'
    };
    return departmentMap[department.toLowerCase()] || 'Support'; // Default to Support
  }
  
  // Update an existing ticket
  async updateTicket(ticketId: string, ticketData: any): Promise<any> {
    return await this.request(`/api/v1/tickets/${ticketId}`, 'PUT', ticketData);
  }
  
  // Find or create a customer in Zammad
  async findOrCreateCustomer(userData: {
    email: string;
    name: string;
  }): Promise<any> {
    try {
      // Search for the customer
      const searchResult = await this.request(`/api/v1/users/search?query=${encodeURIComponent(userData.email)}`);
      
      if (searchResult && searchResult.length > 0) {
        return searchResult[0]; // Customer exists
      }
      
      // Create a new customer
      const newCustomer = await this.request('/api/v1/users', 'POST', {
        email: userData.email,
        firstname: userData.name.split(' ')[0] || '',
        lastname: userData.name.split(' ').slice(1).join(' ') || '',
        role_ids: [3] // Customer role in Zammad
      });
      
      return newCustomer;
    } catch (error) {
      console.error(`Error finding or creating customer ${userData.email}:`, error);
      throw error;
    }
  }

  // Check if customer exists in Zammad by email
  async findCustomerByEmail(email: string): Promise<any | null> {
    try {
      const searchResult = await this.request(`/api/v1/users/search?query=${encodeURIComponent(email)}`);
      
      if (searchResult && searchResult.length > 0) {
        return searchResult[0]; // Customer exists
      }
      
      return null; // Customer not found
    } catch (error) {
      console.error(`Error finding customer ${email}:`, error);
      return null;
    }
  }

  // Get ticket statistics for a customer
  async getTicketStats(email: string): Promise<{
    total: number;
    open: number;
    pending: number;
    resolved: number;
  }> {
    try {
      const tickets = await this.getTicketsByCustomer(email);
      
      const stats = {
        total: tickets.length,
        open: 0,
        pending: 0,
        resolved: 0
      };

      tickets.forEach((ticket: any) => {
        const status = this.mapZammadStatusToInternal(ticket.state_id);
        switch (status) {
          case 'open':
          case 'in_progress':
            stats.open++;
            break;
          case 'pending':
            stats.pending++;
            break;
          case 'resolved':
          case 'closed':
            stats.resolved++;
            break;
        }
      });

      return stats;
    } catch (error) {
      console.error(`Error getting ticket stats for ${email}:`, error);
      return { total: 0, open: 0, pending: 0, resolved: 0 };
    }
  }

  // Get tickets with expanded data for better display
  async getTicketsWithDetails(email: string): Promise<any[]> {
    try {
      // Use the same approach as getTicketsByCustomer
      return await this.getTicketsByCustomer(email);
    } catch (error) {
      console.error(`Error getting tickets with details for ${email}:`, error);
      return [];
    }
  }
  
  // Map our ticket format to Zammad format
  mapTicketToZammad(ticket: Partial<Ticket>, userEmail: string, userName: string): any {
    return {
      title: ticket.subject,
      customer: {
        email: userEmail,
        name: userName
      },
      article: {
        subject: ticket.subject,
        body: ticket.description,
        type: 'note',
        internal: false,
      },
      state_id: this.mapStatusToZammad(ticket.status as any),
      priority_id: this.mapPriorityToZammad(ticket.priority as any)
    };
  }
  
  // Map our status to Zammad status ID
  private mapStatusToZammad(status?: 'open' | 'in_progress' | 'pending' | 'resolved' | 'closed'): number {
    switch (status) {
      case 'open':
        return 1; // 'new' in Zammad
      case 'in_progress':
        return 2; // 'open' in Zammad
      case 'pending':
        return 3; // 'pending reminder' in Zammad
      case 'resolved':
        return 4; // 'closed' in Zammad
      case 'closed':
        return 6; // 'closed successful' in Zammad
      default:
        return 1; // Default to 'new'
    }
  }
  
  // Map our priority to Zammad priority ID
  private mapPriorityToZammad(priority?: 'low' | 'medium' | 'high' | 'critical'): number {
    switch (priority) {
      case 'low':
        return 1; // 'low' in Zammad
      case 'medium':
        return 2; // 'normal' in Zammad
      case 'high':
        return 3; // 'high' in Zammad
      case 'critical':
        return 4; // 'very high' in Zammad
      default:
        return 2; // Default to 'normal'
    }
  }
  
  // Map Zammad ticket to our format
  mapZammadToTicket(zammadTicket: any): Partial<Ticket> {
    if (!zammadTicket) {
      return {};
    }
    
    return {
      ticketId: zammadTicket.id?.toString(),
      subject: zammadTicket.title,
      description: this.getTicketDescription(zammadTicket),
      status: this.mapZammadStatusToInternal(zammadTicket.state_id) as 'open' | 'in_progress' | 'pending' | 'resolved' | 'closed',
      priority: this.mapZammadPriorityToInternal(zammadTicket.priority_id) as 'low' | 'medium' | 'high' | 'critical'
    };
  }
  
  // Extract the ticket description from Zammad ticket
  private getTicketDescription(zammadTicket: any): string {
    // Try to get the first article body
    if (zammadTicket.articles && zammadTicket.articles.length > 0) {
      return zammadTicket.articles[0].body || '';
    }
    
    // Fallback to an empty string
    return '';
  }
  
  // Map Zammad status ID to our status
  private mapZammadStatusToInternal(stateId: number): 'open' | 'in_progress' | 'pending' | 'resolved' | 'closed' {
    switch (stateId) {
      case 1: // 'new' in Zammad
        return 'open';
      case 2: // 'open' in Zammad
        return 'in_progress';
      case 3: // 'pending reminder' in Zammad
      case 5: // 'pending close' in Zammad
        return 'pending';
      case 4: // 'closed' in Zammad
      case 6: // 'closed successful' in Zammad
      case 7: // 'closed unsuccessful' in Zammad
        return 'closed';
      default:
        return 'open';
    }
  }
  
  // Map Zammad priority ID to our priority
  private mapZammadPriorityToInternal(priorityId: number): 'low' | 'medium' | 'high' | 'critical' {
    switch (priorityId) {
      case 1: // 'low' in Zammad
        return 'low';
      case 2: // 'normal' in Zammad
        return 'medium';
      case 3: // 'high' in Zammad
        return 'high';
      case 4: // 'very high' in Zammad
        return 'critical';
      default:
        return 'medium';
    }
  }
}

export const zammadService = new ZammadService();
